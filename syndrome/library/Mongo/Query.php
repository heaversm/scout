<?php
/**
 * Abstract query builder class for creating mongo db queries
 *
 * @author Man Hoang
 * @name Mongo_Query
 */
class Mongo_Query {

	/**
	 * The internal properties of this query
	 * @var array
	 */
	protected $properties = array();

	/**
	 * The parsed properties of the mongo array
	 * @var array
	 */
	protected $query = array();

	/**
	 * The queried columns
	 * @var array
	 */
	protected $column_names = array();

	/**
	 * The pool used to query the database
	 * @var string
	 */
	protected $pool;

	/**
	 * The last insert id generated by this query
	 * @var array
	 */
	protected $insert_id = array();

	/**
	 * Debugging flag
	 * @var bool
	 */
	protected $is_debug = false;
	
	protected $sanitize_strings = true;

	/**
	 * Translates standard type where conditions to mongo where conditions
	 * @var array
	 */
	protected static $criteria_matrix = array(
		'=' => '=',
		'<' => '$lt',
		'<=' => '$lte',
		'>' => '$gt',
		'>=' => '$gte',
		'all' => '$all',
		'exist' => '$exists',
		'%' => '$mod',
		'!=' => '$ne',
		'in' => '$in',
		'not in' => '$nin',
		'nor' => '$nor',
		'or' => '$or',
		'and' => '$and',
		'size' => '$size',
		'type' => '$type',
		'like' => '$regex',
		'regex' => '$regex'
	);
	
	const MONGO_32BIT_LIMIT = 2147483647;

	/**
	 * Create a new Mongo_Query object
	 *
	 * @param string $table
	 * @param string $pool
	 */
	protected function __construct($table, $pool = null) {
		$this->pool = null;
		$this->table($table);
	}

	/**
	 * Creates a chainable Mongo_Query object
	 *
	 * @param string $table
	 * @param string $pool
	 * @return Mongo_Query
	 */
	public static function create($table, $pool = null) {
		return new self($table, $pool);
	}

	/**
	 * Enables debugging mode
	 *
	 * @return Mongo_Query
	 */
	public function debug() {
		$this->is_debug = true;
		return $this;
	}

	/**
	 * Enables debugging mode
	 * 
	 * @param bool
	 * @return Mongo_Query
	 */
	public function setSanitizeStrings($sanitize_strings) {
		$this->sanitize_strings = $sanitize_strings;
		return $this;
	}

	/**
	 * Retrieves the mongo collection used to execute this query
	 *
	 * @param string $table
	 * @return MongoCollection
	 */
	protected function getCollection(&$table) {
		if(!isset($table) || !Mongo_Schema::getInstance()->collectionExists($table)) {
			throw new Exception('No collection specified for mongo query.');
		}
		$collection = Mongo_Manager::getInstance()->getCollection($table, $this->pool);
		return $collection;
	}

	/**
	 * Type casts all values in a object
	 *
	 * @param mixed $values
	 * @param int $depth Internally used variable, do not override!
	 * @return mixed
	 */
	protected function sanitize($values, $depth = 0) {
		if($depth > 10) {
			throw new Exception('Too much recursion in mongo sanitize.');
		}
		// recursive iteration on array values
		if(is_array($values)) {
			$return = array();
			$depth++;
			foreach($values as $key => $value) {
				if(strpos($key, '$') === 0) {
					throw new Exception('Key starting with "$" being inserted into mongo sanitize.');
				}
				if($key === '_id' && !is_array($value)) {
					// special case for mongo id values
					$return[$key] = new MongoId($value);
				} else {
					$return[$key] = $this->sanitize($value, $depth);
				}
			}
			return $return;
		}
		if(is_object($values)) {
			return $values;
		}
		// numeric values don't need to be escaped
		if(!is_numeric($values) || is_float($values) || is_int($values)) {
			if(is_int($values) && $values > self::MONGO_32BIT_LIMIT) {
				return new MongoInt64($values);
			}
			return $values;
		}
		if(is_numeric($values)) {
			return intval($values);
		}
		if(is_string($values)) {
			return $this->sanitize_strings ? Helper_Clean::dbSafeText($values) : $values ;
		}
		$intval = intval($values);
		return (strlen($values) != strlen($intval) && $intval != 0) ? floatval($values) : $intval;
	}

	/**
	 * Gets the insert id of the most recently run insert query
	 *
	 * @return mixed
	 */
	public function getInsertId() {
		$records = count($this->insert_id);
		if($records === 0) {
			return null;
		}
		return $records > 1 ? $this->insert_id : $this->insert_id[0];
	}

	/**
	 * Generate and execute a mongo explain on the select query
	 *
	 * @return array
	 */
	public function explain() {
		return $this->select(true)->explain();
	}

	/**
	 * Generate and execute a mongo explain on the select query
	 *
	 * @return array
	 */
	public function count() {
		if($this->is_debug) {
			return $this->debugCount();
		}

		$collection = $this->getCollection($this->properties['table']);
		return $collection->count($this->generateCriteria(), isset($this->properties['limit']) ? $this->properties['limit'] : 0, isset($this->properties['offset']) ? $this->properties['offset'] : 0);
	}
	
	public function ensureIndex($collection, $index, $background = true) {
		return $collection->ensureIndex($index, array('background' => $background));
	}

	/**
	 * Generates and executes a find query from a mongo database
	 *
	 * @param bool $raw_result
	 * @return array|MongoCursor
	 */
	public function find($raw_result = false) {
		if($this->is_debug) {
			return $this->debugFind();
		}

		$collection = $this->getCollection($this->properties['table']);
		$docs = $collection->find($this->generateCriteria(), $this->generateColumns());
		// if we got nothing back or there was some issue?
		if($docs === null) {
			return $raw_result ? null : array();
		}
		// parse sorting order
		if(isset($this->properties['order'])) {
			$order_by = array();
			foreach($this->properties['order'] as $order) {
				$order_by[$order['column']] = $order['order'];
			}
			$docs->sort($order_by);
		}
		// if there is a offset, tell the cursor that there is a offset
		if(isset($this->properties['offset'])) {
			$docs->skip($this->properties['offset']);
		}
		// if there is a limit, tell the cursor that there is a limit
		if(isset($this->properties['limit'])) {
			$docs->limit($this->properties['limit']);
		}

		// return what we wanted!
		return $raw_result ? $docs : iterator_to_array($docs);
	}

	/**
	 * Generates and executes a select query from a mongo database and returns the first row
	 *
	 * @return array
	 */
	public function findOne() {
		if($this->is_debug) {
			return $this->debugFindOne();
		}
		$collection = $this->getCollection($this->properties['table']);
		$doc = $collection->findOne($this->generateCriteria(), $this->generateColumns());
		return $doc === null ? array() : $doc;
	}

	/**
	 * Generates and executes a select query from a mongo database and returns the first result of the first row
	 * if it doesn't exists, return a default value
	 *
	 * @param string $column
	 * @param mixed $default_value
	 * @return mixed
	 */
	public function findValue($column, $default_value = false) {
		// just pull out this one column
		$this->columns($column);
		$doc = $this->findOne();
		if(empty($doc)) {
			return $default_value;
		}
		return isset($doc[$column]) ? $doc[$column] : $default_value;
	}

	/**
	 * Generates and executes a insert query from a mongo database
	 *
	 * @return int The number of documents inserted|insert id
	 */
	public function insert() {
		if($this->is_debug) {
			return $this->debugInsert();
		}
		$affected = 0;
		$collection = $this->getCollection($this->properties['table']);
		foreach($this->properties['values'] as $set) {
			$affected += $collection->insert($set);
			$this->insert_id[] = $set['_id']->__toString();
		}
		
		return $affected;
	}

	/**
	 * Generates and executes a update query from a mongo database
	 *
	 * @param bool $multiple If true, it will update all documents matching the criteria, otherwise it will only modify the first
	 * @param bool $upsert If true, will be equivalent to insert on dupe key update with values being the new values + criteria
	 * @param bool $overwrite If true, the update will overwrite the found documents with the new value
	 * @return bool
	 */
	public function update($multiple = true, $upsert = false, $overwrite = false) {
		if($this->is_debug) {
			return $this->debugUpdate($multiple, $upsert, $overwrite);
		}

		// generate query options
		$options = array();
		$options['multiple'] = !!$multiple;
		if($upsert) {
			$options['upsert'] = true;
		}

		// if we are not overwriting, then we need to say $set
		$values = $overwrite ? $this->properties['values'][0] : $this->generateUpdateValues();

		$collection = $this->getCollection($this->properties['table']);
		return $collection->update($this->generateCriteria(), $values, $options);
	}

	/**
	 * Generates and executes a delete query from a mongo database
	 *
	 * @param bool $multiple If true, all documents matching the criteria will be removed
	 * @return bool
	 */
	public function remove($multiple = true) {
		if($this->is_debug) {
			return $this->debugRemove($multiple);
		}

		// generate query options
		$options = array();
		$options['justOne'] = !$multiple;

		$collection = $this->getCollection($this->properties['table']);
		return $collection->remove($this->generateCriteria(), $options);
	}

	/**
	 * Generates and executes a truncate query from a mongo database (will empty a collection but will not delete it)
	 *
	 * @return bool
	 */
	public function truncate() {
		if($this->is_debug) {
			return $this->debugTruncate();
		}
		$collection = $this->getCollection($this->properties['table']);
		$result = $collection->remove(array());
		return isset($result['ok']) && $result['ok'] == 1;
	}

	/**
	 * Generates and executes a drop collection query from a mongo database
	 *
	 * @return bool
	 */
	public function drop() {
		if($this->is_debug) {
			return $this->debugDrop();
		}
		$collection = $this->getCollection($this->properties['table']);
		$result = $collection->drop();
		return isset($result['ok']) && $result['ok'] == 1;
	}

	/**
	 * Generate and execute a mongo explain on the select query
	 *
	 * @return array
	 */
	protected function debugCount() {
		echo 'db.' . htmlentities($this->properties['table']) . '.find(' . Helper_Format::printJson($this->generateCriteria()) . ')';

		// if there is a offset, tell the cursor that there is a offset
		if(isset($this->properties['offset'])) {
			echo '.skip(' . $this->properties['offset'] . ')';
		}
		// if there is a limit, tell the cursor that there is a limit
		if(isset($this->properties['limit'])) {
			echo '.limit(' . $this->properties['limit'] . ')';
		}
		echo '.count();';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a select query from a mongo database
	 *
	 * @return array
	 */
	protected function debugFind() {
		echo 'db.' . htmlentities($this->properties['table']) . '.find(';
		echo Helper_Format::printJson($this->generateCriteria());
		echo ', ';
		echo Helper_Format::printJson($this->generateColumns());
		echo ')';
		// parse sorting order
		if(isset($this->properties['order'])) {
			$order_by = array();
			foreach($this->properties['order'] as $order) {
				$order_by[$order['column']] = $order['order'];
			}
			echo '.sort(' . Helper_Format::printJson($order) . ')';
		}

		// if there is a offset, tell the cursor that there is a offset
		if(isset($this->properties['offset'])) {
			echo '.skip(' . $this->properties['offset'] . ')';
		}
		// if there is a limit, tell the cursor that there is a limit
		if(isset($this->properties['limit'])) {
			echo '.limit(' . $this->properties['limit'] . ')';
		}
		echo ';';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a select query from a mongo database and returns the first row
	 *
	 * @return array
	 */
	protected function debugFindOne() {
		echo 'db.' . htmlentities($this->properties['table']) . '.findOne(';
		echo Helper_Format::printJson($this->generateCriteria());
		echo ', ';
		echo Helper_Format::printJson($this->generateColumns());
		echo ');';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a insert query from a mongo database
	 *
	 * @param int
	 */
	protected function debugInsert() {
		foreach($this->properties['values'] as $set) {
			echo 'db.' . htmlentities($this->properties['table']) . '.insert(';
			echo Helper_Format::printJson($set);
			echo ');';
			echo PHP_EOL;
		}
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a update query from a mongo database
	 *
	 * @param bool $multiple If true, it will update all documents matching the criteria, otherwise it will only modify the first
	 * @param bool $upsert If true, will be equivalent to insert on dupe key update with values being the new values + criteria
	 * @param bool $overwrite If true, the update will overwrite the found documents with the new value
	 * @return bool
	 */
	protected function debugUpdate($multiple = true, $upsert = false, $overwrite = false) {
		$options = array();
		$options['multiple'] = !!$multiple;
		if($upsert) {
			$options['upsert'] = true;
		}
		// if we are not overwriting, then we need to say $set
		$values = $overwrite ? $this->properties['values'][0] : $this->generateUpdateValues();
		echo 'db.' . htmlentities($this->properties['table']) . '.update(';
		echo Helper_Format::printJson($this->generateCriteria());
		echo ', ';
		echo Helper_Format::printJson($values);
		echo ', ';
		echo Helper_Format::printJson($options);
		echo ');';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a delete query from a mongo database
	 *
	 * @param bool $multiple If true, all documents matching the criteria will be removed
	 * @return bool
	 */
	protected function debugRemove($multiple = true) {
		$options = array();
		$options['justOne'] = !$multiple;

		echo 'db.' . htmlentities($this->properties['table']) . '.remove(';
		echo Helper_Format::printJson($this->generateCriteria());
		echo ', ';
		echo Helper_Format::printJson($options);
		echo ');';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a truncate query from a mongo database
	 *
	 * @return bool
	 */
	protected function debugTruncate() {
		echo 'db.' . htmlentities($this->properties['table']) . '.remove([]);';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Generates and executes a truncate query from a mongo database
	 *
	 * @return bool
	 */
	protected function debugDrop() {
		echo 'db.' . htmlentities($this->properties['table']) . '.drop();';
		echo PHP_EOL;
		throw new Exception("Mongo debugging enabled!");
		return array();
	}

	/**
	 * Select the collection to query from
	 *
	 * @param string $table
	 * @return Mongo_Query
	 */
	public function table($table = '') {
		if(!Mongo_Schema::getInstance()->collectionExists($table)) {
			throw new Exception('Trying to query a table that does not exist: ' . $table);
		}
		$this->properties['table'] = $table;
		return $this;
	}

	/**
	 * Add parameters for WHERE clause. Add table.col or tablealias.col if column is in multiple tables being used
	 * Submit a bunch of WHERE statements in a single array via $param1
	 *
	 * @param string $column
	 * @param mixed $value
	 * @param string $criteria =, <, >, !=, <=, >=
	 * @return Mongo_Query
	 */
	public function where($column, $value, $criteria = '=') {
		$this->properties['where'][] = array(
			'column' => $column,
			'value' => $this->sanitize($value),
			'criteria' => $criteria
		);
		return $this;
	}

	/**
	 * Add parameters for WHERE clause With OR. Add table.col or tablealias.col if column is in multiple tables being used
	 * Submit a bunch of WHERE statements in a single array via $param1
	 * @param string/array $param1 column reference or value
	 * @param string/array $param2 column reference or value
	 * @param string $criteria =, <, >, !=, <=, >=
	 * @return Mongo_Query
	 */
	public function whereOr($param1 = '', $param2 = '', $criteria = '=') {
		throw new Exception('Method "whereOr" not yet implemented!');
		return $this;
	}

	/**
	 * Adds a column to group by
	 *
	 * @param string $column
	 * @return Mongo_Query
	 */
	public function groupBy($column) {
		throw new Exception('Method "groupBy" not yet implemented!');
		return $this;
	}

	/**
	 * Add column ordering
	 *
	 * @param string $column column to order by
	 * @param string $order ASC/DESC order for column
	 * @return Mongo_Query
	 */
	public function orderBy($column, $order = 'ASC') {
		if(!$column) {
			return $this;
		}
		$this->properties['order'][] = array(
			'column' => $column,
			'order' => $order == 'ASC' ? 1 : -1
		);
		return $this;
	}

	/**
	 * Add columns for find statement
	 *
	 * @param string|array $column
	 * @param mixed $condition
	 * @return Mongo_Query
	 */
	public function columns($column, $condition = 1) {
		if(is_array($column)) {
			foreach($column as $col) {
				$this->column_names[$col] = 1;
			}
		} else {
			$this->column_names[$column] = $this->sanitize($condition);
		}
		return $this;
	}

	/**
	 * Add a limit to query
	 * @param int $limit max number of rows to select/update/delete
	 * @return Mongo_Query
	 */
	public function limit($limit = 0) {
		if($limit > 0) {
			$this->properties['limit'] = $limit;
		}
		return $this;
	}

	/**
	 * Add offset for interacting with rows
	 * @param int $offset rows to offset before select/update/delete
	 * @return Mongo_Query
	 */
	public function offset($offset = 0) {
		if($offset > 0) {
			$this->properties['offset'] = $offset;
		}
		return $this;
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values
	 * @return Mongo_Query
	 */
	public function values($values = array()) {
		if($values != null) {
			$this->properties['values'][] = $this->sanitize($values);
		}
		return $this;
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values column=>value relationship
	 * @return Mongo_Query
	 */
	public function increment($column, $by = 1) {
		if($column) {
			$this->properties['inc_values'][] = array(
				'column' => $column,
				'value' => $this->sanitize($by)
			);
		}
		return $this;
	}

	/**
	 * adds a column to decrement from the current value
	 *
	 * @param string $column
	 * @param int $incremental
	 * @return Query
	 */
	public function decrement($column, $by = 1) {
		return $this->increment($column, -1 * $by);
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values column=>value relationship
	 * @return Mongo_Query
	 */
	public function push($column, $value) {
		if($column) {
			$this->properties['push_values'][] = array(
				'column' => $column,
				'value' => $this->sanitize($value)
			);
		}
		return $this;
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values column=>value relationship
	 * @return Mongo_Query
	 */
	public function add($column, $value) {
		throw new Exception('Method "add" not yet implemented!');
		return $this;
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values column=>value relationship
	 * @return Mongo_Query
	 */
	public function pop($column, $value) {
		throw new Exception('Method "pop" not yet implemented!');
		return $this;
	}

	/**
	 * Add values to properties array for updating and inserting
	 *
	 * @param array $values column=>value relationship
	 * @return Mongo_Query
	 */
	public function pull($column, $value) {
		throw new Exception('Method "pull" not yet implemented!');
		return $this;
	}

	/**
	 * Generates the "where" criteria field for a mongo query
	 *
	 * @return array
	 */
	protected function generateCriteria() {
		// no where condition
		if(!isset($this->properties['where'])) {
			return array();
		}
		$where = array();
		// format the where conditions
		foreach($this->properties['where'] as $condition) {
			$operator = $this->translateWhereOperator($condition['criteria']);
			if($operator == '=') {
				$where[$condition['column']] = $condition['value'];
			} elseif($operator == '$type') {
				$where[$condition['column']][$operator] = $condition['value'];
				throw new Exception('Where operator "$type" not yet implemented!');
			} elseif($operator == '$regex') {
				$where[$condition['column']][$operator] = new MongoRegex($condition['value']);
			} else {
				$where[$condition['column']][$operator] = $condition['value'];
			}
		}

		return $where;
	}

	/**
	 * Translates the where operator to the mongo form
	 *
	 * @param string $operator
	 * @return string
	 */
	protected function translateWhereOperator($operator) {
		return self::$criteria_matrix[strtolower($operator)];
	}

	/**
	 * Generates the "columns" criteria field for a mongo query
	 *
	 * @return array
	 */
	protected function generateColumns() {
		if(empty($this->column_names)) {
			return array();
		}
		return $this->column_names;
	}

	/**
	 * Generates the array of values to be updated in the mongo document
	 *
	 * @return array
	 */
	protected function generateUpdateValues() {
		$update = array();

		// standard update of values
		if(isset($this->properties['values']) && !empty($this->properties['values'])) {
			$update['$set'] = $this->properties['values'][0];
		}
		// value incrementing
		if(isset($this->properties['inc_values']) && !empty($this->properties['inc_values'])) {
			$inc = array();
			foreach($this->properties['inc_values'] as $x) {
				$inc[$x['column']] = $x['value'];
			}
			$update['$inc'] = $inc;
		}
		// item pushing into object
		if(isset($this->properties['push_values']) && !empty($this->properties['push_values'])) {
			$push = array();
			$pushAll = array();
			foreach($this->properties['push_values'] as $x) {
				if(is_array($x['value'])) {
					$pushAll[$x['column']] = $x['value'];
				} else {
					$push[$x['column']] = $x['value'];
				}
			}
			if(!empty($push)) {
				$update['$push'] = $push;
			}
			if(!empty($pushAll)) {
				$update['$pushAll'] = $pushAll;
			}
		}

		return $update;
	}
}